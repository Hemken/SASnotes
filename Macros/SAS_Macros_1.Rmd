# Macro Variables

```{r setup, include=FALSE}
library(SASmarkdown)
```

The SAS Macro language enables you to write programs that generate SAS code, which is then submitted to the SAS interpreter for execution.  A macro can be as simple as text substitution, creating a short placeholder for a long string of code, or a macro can generate SAS code dynamically, generating different code depending upon some input.

We will want to distinguish between *macro variables*, which are simple placeholders, and *macros*, which are usually code-generating.

## Macro Variables and %LET
Working with macro variables is a two-part process.  First you assign a value to a macro variable - this value will be some string of text.  Then you use the macro variable to substitute that text into some block of SAS code.  This is called *macro resolution*.

Although macro values are text, you typically do not use quotes in defining them - if you do, the quotes are included when the text is substituted.

A macro value will typically be a token, a token fragment, or a collection of tokens.  To make a macro value include more than one SAS statement requires the use of macro functions, and this is more typically done as a *macro* than as a *macro variable*.  Where the value is a token fragment to be combined with a suffix, the macro variable is called with a leading ampersand and a trailing period.

A macro value may be hard-coded as a constant, but it can also be defined as the result of macro functions.  Whatever is on the right-hand side of the equals sign in a %LET statement is evaluated before the assignment is made.

Note that when you create a macro variable, you give it a SAS name following the same rules you use for variable names within data sets (no spaces, no special characters, capitalization does not matter).  When you go to use the macro variable, the name is always prefixed by an ampersand, \"\&\".


```{sas libnames, include=FALSE, collectcode=TRUE}
libname y "Z:\PUBLIC_web_source\SASnotes\Macros";
libname library (y);
```

In the following example, we just illustrate with two marital
status variables (different years).  Imagine how much output
would be produced if we used the full list.
```{sas let}  
* Assigning values to macro variables;
%let dsn = y.nlswomen;
%let mstatus = R0002400 R0133700 /*R0205100 R0288200 
	R0308300 R0367600 R0455600 R0491300 R0661400 R0666600 R0721700 
	R0869900 R0997700 R1290700 R1664710 R3507200 R4278200 
	R5447500 R6516200*/;

* Using the macro variables;
proc freq data=&dsn;
	tables &mstatus / nocum;
run;
```

By default the code that is echoed in the log is just what you
send to the macro interpreter.  If you want to see what the code
looks like after macro variable substitution, you need to invoke
the SAS option SYMBOLGEN.  In much of the SAS documentation,
macro variables are called \"symbols\" and lists of macro variables
are called \"symbol tables\". Your log will look like this:

```{sas symbolgen, eval=FALSE}
%let dsn = y.nlswomen;
%let mstatus = R0002400 R0133700 ;

options symbolgen;
proc freq data=&dsn;
	tables &mstatus / nocum;
run;
```

Notice the echo of PROC FREQ includes notes on the macro values used.

```{saslog symbolgen}
```

More examples:
```{saslog}
%let test = TEXT;
%put test=&test;

%let test = "TEXT";
%put test=&test;
```


If a macro variable contains a semi-colon, use the *macro
function* `%quote`.
```{sas}
%LET test = %quote(proc print; run;);

data class; 
  set sashelp.class;
run;
&test;
```

## Additional Reading

- Delwiche and Slaughter, *The Little SAS Book*, Chapter 7
- [Delwiche and Slaugher, \"SAS Macro Programming for Beginners\"](http://support.sas.com/resources/papers/proceedings11/258-2011.pdf)
- [Stroupe, \"Nine Steps to Get Started Using SAS Macros\"](http://www2.sas.com/proceedings/sugi28/056-28.pdf)
